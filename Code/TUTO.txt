
Les systèmes de signaux/slots sont utilesé pour gerer des évenements, plus precisement ,
des évenements qui peuvent declancher un grand nombre de fonction !

SISL le fait simplement, et je vais vous montrez comment !



SISL est composé de 2 groupes de classes : SIGNAL et SLOT

le but d'un signal est d'appeler un ou plusieurs slot en lui passant ou non un paramètre.


SIGNAL_0 et SLOT_0 permettent de gerer les signaux et slots sans paramètres
SIGNAL_1<monType> et SLOT_1<monType> permettent de gerer le signaux et slots avec un paramètres de type "monType"





Pour utiliser SISL : faites tout simplement un #include "SISL.h"

( NB : toute les classes et fonctions de SISL sont dans le namespace sisl:: )

Creons ensemble une classe "Bouton" qui contient un signal "sig_clicked" ( ce signal pouvant etre declanché lorsque l'utilisateur clique sur le bouton ^^)



class Bouton
{
    public:

    Bouton(){}

    sisl::SIGNAL_0 sig_clicked;
}



Developpeur lambda : " Mais ! Ô Grand Asphox, SIGNAL_0 est un objet ! et tu l'as mis en public !!! normalement les attributs d'une classe doivent etre privés non ?! D:"

Oui tu as raison petit scarabé, normalement tout les atttributs doivent etre privés dans une class, mais il peut y avoir des excpetions !
Pour simplifier : SIGNAL_0 / SIGNAL_1 / SLOT_0 / SLOT_1 , malgré qu'ils soient des objets, representent ( en quelque sorte ) des methodes ! tu peux ( et tu DOIS !! ) les mettres en public ^^

bien ! maintenant nous avons notre bouton , avec un signal correspondant au clique sur le bouton.
Mais un signal qui ne declanche rien ... ne sert a rien ! Nous allons donc creer une deuxieme class ( Inventaire ) qui doit afficher un inventaire quand le bouton coder precedement est cliqué ^^


Allons y !

Class Inventaire
{
    private:
    void _fctSlot_display(){ /*code pour afficher l'inventaire à l'ecran*/ }

    public:

    sisl::SLOT_0 slot_display;

    Inventaire(){

        slot_display.attach(&Inventaire::_fctSlot_display,this);

    }

}


Houlà , ça se complique un peu non ? =3

regardons ça en details :
le but d'un slot et d'executer du code quand il est appelé, nous allons donc mettre le code qui affiche l'inventaire a l'ecran dans une methode privés, ici "_fctSlot_display()" !

une fois notre petite methode codé, on creer un SLOT_0 (public) dans notre classe, on l'appel slot_display !

dans le constructeur de la class Inventaire, on va tout simplement attacher le fonction qui affiche l'inventaire au slot correspondant ! avec : slot_display.attach(&Inventaire::_fctSlot_display,this);

et c'est tout !!! nous avons notre SLOT ^w^



Maintenant , il faut connecter le signal du bouton , avec le slot de l'inventaire :

int main()
{
    Bouton bouton;
    Inventaire inventaire;

    sisl::connect(&bouton.sig_clicked,&inventaire.slot_display);        //je connect le signal du bouton au slot de l'inventaire !

    /*si le bouton est cliqué, il faut appeler : */
    bouton.sig_clicked.emit();

    return 0;
}

et c'est tout ! des que sig_clicked est emis, l'inventaire s'affichera a l'ecran ! peut importe quand il est emit, et peux importe d'où il est emit !

(NB : il est possible de connecter le signal et le slot de cette maniere aussi :     bouton.sig_clicked.connect(&inventaire.slot_display);     )

et l'on peut connecter une infinité de slot a un meme signal bien entendu !


<============Approfondir===========>

dans le meme principe, si le slot a besoin d'un parametre lorsqu'il est appeler (pour recevoir le nom d'un personnage qui aurait été emit precedement par exemple !)

il faut utiliser les classes SIGNAL_1 et SLOT_1  ( 1 pour 1 parametre ^w^ )

SIGNAL_1<std::string>   un signal qui emet un string
SLOT_1<std::string> un slot qui reçois un string


il faut penser lors du emit, a passer le paramètre !

ex : perso.sig_mort.emit("Aaaarhg... je suis mort");








il est aussi possible d'attacher une fonction qui n'appartient pas a une class !

comme ceci :


void maFonction(){}


Class maClass
{

    public:

    sisl::SLOT_0 monSlot;

    Inventaire(){

        monSlot.attach(maFonction);

    }

}

tout simplement ^w^




SI vous voulez deconnecter un slot d'un signal, il faut utiliser "disconnect"

monSignal.disconnect(&monSlot);

ou

sisl::disconnect(&monSignal,&monSlot);


ou monSignal.disconnect_all(); pour tout deconnecter !



